import 'dart:convert';
import 'dart:developer' as developer;
import 'package:dio/dio.dart';
import '../../../../core/network/dio_client.dart';
import '../../../../core/config/api_config.dart';
import '../models/login_models.dart';
import '../models/user_model.dart';

abstract class AuthApiService {
  Future<LoginResponse> signInWithEmail(String email, String password);
  Future<void> signOut();
  Future<User?> getCurrentUser();
  Future<QRLoginResponse> validateQRCode(String qrData, String origin);
  Future<Map<String, dynamic>?> getSession();
}

class AuthApiServiceImpl implements AuthApiService {
  final DioClient _dioClient;

  AuthApiServiceImpl(this._dioClient);

  @override
  Future<LoginResponse> signInWithEmail(String email, String password) async {
    try {
      developer.log('Sign-in attempt with email: $email');
      final response = await _dioClient.post(
        ApiConfig.signInEmail,
        data: {
          'email': email,
          'password': password,
        },
      );

      if (response.statusCode == 200) {
        return LoginResponse.fromJson({
          'message': 'Login successful',
          'success': true,
        });
      } else {
        throw DioException(
          requestOptions: response.requestOptions,
          response: response,
          message: 'Login failed with status: ${response.statusCode}',
        );
      }
    } on DioException catch (e) {
      // Parse error response from Better Auth
      final errorData = e.response?.data;
      String errorMessage = 'Login failed';

      if (errorData is Map<String, dynamic>) {
        errorMessage = errorData['message'] ?? errorData['error'] ?? errorMessage;
      } else if (errorData is String) {
        errorMessage = errorData;
      }

      throw Exception(errorMessage);
    } catch (e) {
      throw Exception('Network error: ${e.toString()}');
    }
  }

  @override
  Future<void> signOut() async {
    try {
      await _dioClient.post(ApiConfig.signOut);
    } on DioException catch (e) {
      // Even if sign out fails, we should proceed with local cleanup
      // Better Auth might return errors but still clear the session
      print('Sign out API call failed: ${e.message}');
    }
  }

  @override
  Future<User?> getCurrentUser() async {
    try {
      final response = await _dioClient.get(ApiConfig.merchantProfile);

      if (response.statusCode == 200 && response.data != null) {
        // Handle membership response format
        final data = response.data;
        if (data is Map<String, dynamic> && data.containsKey('membership')) {
          final membership = data['membership'] as Map<String, dynamic>;
          return User.fromMembershipJson(membership);
        } else {
          // Fallback to direct user parsing (legacy format)
          return User.fromJson(data);
        }
      }
      return null;
    } on DioException catch (e) {
      if (e.response?.statusCode == 401) {
        // User not authenticated
        return null;
      }
      print('Failed to get current user: ${e.message}');
      return null;
    } catch (e) {
      print('Error getting current user: ${e.toString()}');
      return null;
    }
  }

  @override
  Future<QRLoginResponse> validateQRCode(String qrData, String origin) async {
    /*
     * QR Login Flow:
     * 1. Merchant web app generates encrypted QR codes with login credentials
     * 2. Mobile app scans QR code and sends raw encrypted data to backend
     * 3. Backend decrypts QR data and validates it hasn't expired
     * 4. Backend returns decrypted login credentials (email, password, userId, merchantId)
     * 5. Mobile app uses returned credentials to perform normal authentication
     *
     * IMPORTANT: Only QR codes generated by the merchant system's login feature will work.
     * Random QR codes, even if they contain data, will be rejected as invalid.
     */
    try {
      final requestData = <String, dynamic>{
        'qrData': qrData,
      };

      // Only include origin if it's not empty
      if (origin.isNotEmpty) {
        requestData['origin'] = origin;
      }

      developer.log('QR Login Request Data: $requestData');
      developer.log('Making QR validation request...');

      final response = await _dioClient.post(
        ApiConfig.qrLogin,
        data: requestData,
      );

      developer.log('QR validation response status: ${response.statusCode}');

      if ((response.statusCode == 200 || response.statusCode == 201) && response.data != null) {
        developer.log('QR validation successful, parsing response...');
        final qrResponse = QRLoginResponse.fromJson(response.data);
        developer.log('QR response parsed: email=${qrResponse.email}');
        return qrResponse;
      } else {
        developer.log('QR validation failed with status: ${response.statusCode}');
        throw DioException(
          requestOptions: response.requestOptions,
          response: response,
          message: 'QR validation failed with status ${response.statusCode}',
        );
      }
    } on DioException catch (e) {
      developer.log('QR Login DioException: ${e.message}');
      developer.log('QR Login Error Response: ${e.response?.data}');

      final errorData = e.response?.data;
      String errorMessage = 'QR code validation failed';

      if (errorData is Map<String, dynamic>) {
        final data = errorData['data'] as Map<String, dynamic>?;
        errorMessage = data?['message'] ?? errorData['message'] ?? errorMessage;

        // Add more specific error information
        if (errorData['error'] == 'Unauthorized') {
          errorMessage = 'QR code authentication failed. Please ensure you\'re scanning a valid login QR code from the merchant system.';
        }
      }

      throw Exception(errorMessage);
    } catch (e) {
      developer.log('QR Login Unexpected Error: $e');
      throw Exception('Network error during QR validation: ${e.toString()}');
    }
  }

  @override
  Future<Map<String, dynamic>?> getSession() async {
    try {
      final response = await _dioClient.get(ApiConfig.getSession);

      if (response.statusCode == 200 && response.data != null) {
        return response.data as Map<String, dynamic>;
      }
      return null;
    } on DioException catch (e) {
      if (e.response?.statusCode == 401) {
        // Session expired or invalid
        return null;
      }
      print('Failed to get session: ${e.message}');
      return null;
    } catch (e) {
      print('Error getting session: ${e.toString()}');
      return null;
    }
  }
}
